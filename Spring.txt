Spring 创建对象的四种方式的不同应用场景

1. 无参和有参构造创建实例  本质就是把类交给Spring自带的工厂管理，由Spring自带的工厂模式帮我们维护和创造这个类的实例 多用于开发过程中自己编写的类

 2.静态工厂创建实例 ，由Spring帮我们调用创建实例的方法 但 创建实例的过程是由我们自己的静态工厂实现的 使用第三方jar包时 类没有构造方法 只能通过第三方 jar包提供的静态工厂来创建实例

3.实例工厂创建实例 由Spring创建工厂的实例对象 并且调用工厂类的方法创建实例对象也是由Spring管理的。 Spring 整合框架时比如mybatis就是由这种方式实现的 



代理模式的作用  是面向方法的操作面向切面（AOP） 在不侵入的情况下来扩展方法

实现静态代理的方式  继承的方式

实现静态代理的方式 通过实现接口



动态 代理的两种方式 jdk代理和cglib代理

jdk代理只能针对有接口类的接口方法进行代理

cglib基于继承的方式实现代理 因此无法对static ，final类进行代理

cglib无法对static，private方法代理



AOP是一种思想 代理模式是对AOP思想的一种实现

面向切面 一种形象的比喻 把每个方法看做是一个楼层 一个类的多个方法就是多层楼



AOP 是一个类是定义对具体方法怎样进行拓展与分层

joinpoint 要进行拓展与分层的方法

pointcut 在何时进行方法拓展

advice  对目标类方法进行拓展的方法

target  需要被代理的类的对象

weave 实现代理并调用拓展方法的过程 将aspects切面应用到target对象的过程

Spring的事务传播特性

指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行

```
事务的传播行为
propagation,事务的传播行为，默认值是REQUIRED
REQUIRED
  有A,B,C三个方法  B和C的事务传播行为都是REQUIRED
  A方法中调用B和C方法
   1.A方法开启了事务，B和C方法会放在A方法的事务中执行，也就是A,B,C三个方法在同一个事务中
    任意一个方法出现异常 都回导致A,B,C三个方法出现回滚
   2.A方法没有开启事务，B和C方法会分别开启各自的事务，如果出现异常 在自己的内部回滚
SUPPORTS
 有A,B,C三个方法  B和C的事务传播行为都是SUPPROTS
  A方法中调用B和C方法
   1.A方法开启了事务，B和C方法会放在A方法的事务中执行，也就是A,B,C三个方法在同一个事务中
    任意一个方法抛出异常 都回导致A,B,C三个方法出现回滚
   2.A方法没有开启事务，B和C方法不会开启事务 也就是A,B,C三个方法在非事务状态下执行，任意一个放回      出现异常都不会回滚。只会在异常点位置代码停止运行（就是普通的出现异常）
MANDATORY
 有A,B两个方法
  B的事务传播行为是MANDATORY
   A方法中调用B方法
   如果A方法开启了事务 那么可以调用B方法
    如果A方法没有开启事务 那么就会报错
   传播行为是MANDATPRY必须在在开启事务中执行 如果不在事务中执行就会报错
 REQUIRES_NEW
 方法的传播行为是REQUIRES_NEW
  必须在事务中执行，如果当前环境没有事务那么就会新建事务，如果存在多个具有该传播行为的方法 就会各自开启事务
  如果当前环境存在事务，那么将当前事务挂起
  
 
```

![[img]()](https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/image001.jpg)